#include "imports/stdlib.fc";
#include "imports/common.fc";
#include "imports/params.func";
#include "imports/error-codes.fc";

#include "data.func";
#include "bridge.func";
#include "swap.func";
#include "admin.func";
#include "utils.func";

;; storage variables

;; id is required to be able to create different instances of counters
;; since addresses in TON depend on the initial state of the contract
const int ctx_chain_pool_id = 70;

;; This operation is called when the contract receives a notification about a token transfer
() handle_transfer_notification(slice sender_address, slice in_msg_body) impure {
    (int jetton_amount, slice from_user) = (in_msg_body~load_coins(), in_msg_body~load_msg_addr());

    cell ref_cs = in_msg_body~load_ref();
    slice ref_ds = ref_cs.begin_parse();
    int action_op = ref_ds~load_uint(32);

    (int order_id, int swap_id, slice owner, slice withdrawer, slice bridger, cell swap_data) = load_data();

    if (action_op == op::swap_from_jetton) {
        handle_swap_from_jetton(jetton_amount, ref_ds, sender_address);
    } elseif (action_op == op::swap_callback) {
        handle_swap_callback(jetton_amount, sender_address, ref_ds);
    } elseif (action_op == op::bridge_out) {
        slice bridge_token_address = calculate_user_jetton_wallet_address(my_address(), USDT_MASTER_ADDRESS);
        handle_bridge_out(jetton_amount, bridge_token_address, ctx_chain_pool_id, order_id, ref_ds, sender_address);
    } else {
        throw(0xffff); ;; if the message contains an op that is not known to this contract, we throw
    }
}

;; recv_internal is the main function of the contract and is called when it receives a message from other contracts
() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { ;; ignore all empty messages
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) { ;; ignore all bounced messages
        return ();
    }

    slice sender_address = cs~load_msg_addr();
    load_data(); ;; here we populate the storage variables
    int op = in_msg_body~load_uint(32); ;; by convention, the first 32 bits of incoming message is the op
    int query_id = in_msg_body~load_uint(64); ;; also by convention, the next 64 bits contain the "query id", although this is not always the case

    (int order_id, int swap_id, slice owner, slice withdrawer, slice bridger, cell swap_data) = load_data();

    if (op == op::swap_from_ton) {
        handle_swap_from_ton(msg_value, in_msg_body);
    } elseif (op == op::withdrawer::withdraw_ton) {
        handle_withdraw_ton(withdrawer, sender_address);
    } elseif (op == op::withdrawer::withdraw_jetton) {
        handle_withdraw_jetton(withdrawer, sender_address, query_id, in_msg_body);
    } elseif (op == op::bridger::bridge_in) {
        handle_bridge_in(sender_address, bridger, in_msg_body);
    } elseif (op == op::admin::update_address) {
        handle_update_address(sender_address, in_msg_body);
    } elseif (op == op::admin::update_owner) {
        handle_update_owner(sender_address, in_msg_body);
    } elseif (op == op::transfer_notification) {
        handle_transfer_notification(sender_address, in_msg_body);
    } else {
        throw(0xffff); ;; if the message contains an op that is not known to this contract, we throw
    }
}

;; get methods are a means to conveniently read contract data using, for example, HTTP APIs
;; they are marked with method_id
;; note that unlike in many other smart contract VMs, get methods cannot be called by other contracts

slice get_bridge_token_address() method_id {
    return calculate_user_jetton_wallet_address(my_address(), USDT_MASTER_ADDRESS);
}

slice get_withdrawer() method_id {
    (int order_id, int swap_id, slice owner, slice withdrawer, slice bridger, cell swap_data) = load_data();
    return withdrawer;
}

slice get_owner() method_id {
    (int order_id, int swap_id, slice owner, slice withdrawer, slice bridger, cell swap_data) = load_data();
    return owner;
}

slice get_bridger() method_id {
    (int order_id, int swap_id, slice owner, slice withdrawer, slice bridger, cell swap_data) = load_data();
    return bridger;
}

