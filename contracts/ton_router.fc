#include "imports/stdlib.fc";
#include "imports/common.fc";
#include "imports/params.func";
#include "imports/error-codes.fc";

;; storage variables

;; id is required to be able to create different instances of counters
;; since addresses in TON depend on the initial state of the contract
global int ctx_id;
global int ctx_counter;
global int ctx_order_id;
global slice ctx_owner;
global slice ctx_withdrawer;
global slice ctx_bridger;
global slice ctx_bridge_token_address;

;; load_data populates storage variables using stored data
() load_data() impure {
    var ds = get_data().begin_parse();

    ctx_id = ds~load_uint(32);
    ctx_counter = ds~load_uint(32);
    ctx_order_id = ds~load_uint(64);
    ctx_owner = ds~load_msg_addr();

    var addresses_slice = ds~load_ref().begin_parse();
    ctx_withdrawer = addresses_slice~load_msg_addr();
    ctx_bridger = addresses_slice~load_msg_addr();
    ctx_bridge_token_address = addresses_slice~load_msg_addr();

    ds.end_parse();
}

;; save_data stores storage variables as a cell into persistent storage
() save_data() impure {
    set_data(
        begin_cell()
            .store_uint(ctx_id, 32)
            .store_uint(ctx_counter, 32)
            .store_uint(ctx_order_id, 64)
            .store_slice(ctx_owner)
            .store_ref(begin_cell()
                .store_slice(ctx_withdrawer)
                .store_slice(ctx_bridger)
                .store_slice(ctx_bridge_token_address)
                .end_cell()
            )
            .end_cell()
    );
}

;; recv_internal is the main function of the contract and is called when it receives a message from other contracts
() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { ;; ignore all empty messages
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) { ;; ignore all bounced messages
        return ();
    }

    slice sender_address = cs~load_msg_addr();

    load_data(); ;; here we populate the storage variables

    int op = in_msg_body~load_uint(32); ;; by convention, the first 32 bits of incoming message is the op
    int query_id = in_msg_body~load_uint(64); ;; also by convention, the next 64 bits contain the "query id", although this is not always the case

    if (op == transfer_notification) {
        (int jetton_amount, slice from_user) = (in_msg_body~load_coins(), in_msg_body~load_msg_addr());

        ;; sender must be USDT jetton wallet of this contract
        throw_unless(error::unauthorized_transfer, equal_slice_bits(ctx_bridge_token_address, sender_address));

        cell ref_cs = in_msg_body~load_ref();
        slice ref_ds = ref_cs.begin_parse();
        int action_op = ref_ds~load_uint(32);

        if (action_op == op::bridge) {
            slice sender = ref_ds~load_msg_addr();
            slice fromAssetAddr = ref_ds~load_msg_addr();
            int amountIn = ref_ds~load_uint(64);
            int toChainId = ref_ds~load_uint(64);
            int receiver = ref_ds~load_uint(160);
            int tokenOutAddress = ref_ds~load_uint(160);

            ctx_id += toChainId;
            ctx_order_id += 1;

            builder from_ref = begin_cell()
                .store_uint(TON_CHAIN_ID, 64)
                .store_slice(sender)
                .store_slice(fromAssetAddr)
                .store_uint(amountIn, 64);
            builder to_ref = begin_cell()
                .store_uint(toChainId, 64)
                .store_uint(receiver, 160)
                .store_uint(tokenOutAddress, 160);

            emit_log_simple(LOG_BRIDGE_OUT,
                begin_cell()
                    .store_uint(ctx_order_id, 64)
                    .store_ref(from_ref.end_cell())
                    .store_ref(to_ref.end_cell())
                    .store_uint(jetton_amount, 32)
                    .end_cell(), 0);

            save_data();

            return ();
        }
        throw(0xffff); ;; if the message contains an op that is not known to this contract, we throw
    }

    if (op == op::withdrawer::withdraw_ton) {
        throw_unless(error::unauthorized_withdraw, equal_slice_bits(ctx_withdrawer, sender_address));

        raw_reserve(10000000, 2);
        builder msg = create_msg(msg_flag::bounceable, ctx_withdrawer, 0);
        send_raw_message(msg.end_cell(), 128);
        return ();
    }

    if (op == op::withdrawer::withdraw_jetton) {
        throw_unless(error::unauthorized_withdraw, equal_slice_bits(ctx_withdrawer, sender_address));

        slice child_wallet =  in_msg_body~load_msg_addr();
        int amount =  in_msg_body~load_coins();
        cell custom_payload = in_msg_body~load_maybe_ref();

        var msg = begin_cell()
            .store_uint(msg_flag::bounceable, 6)
            .store_slice(child_wallet)
            .store_coins(0)
            .store_msgbody_prefix_ref(
                begin_cell()
                    .store_op(op::transfer)
                    .store_query_id(query_id)
                    .store_coins(amount)
                    .store_slice(ctx_withdrawer)
                    .store_slice(ctx_withdrawer)
                    .store_maybe_ref(custom_payload)
                    .store_coins(0)
                    .store_int(false, 1)
                    .end_cell()
            );
        return send_raw_message(msg.end_cell(), 64);
    }

    if (op == op::bridger::bridge_in) {
        throw_unless(error::unauthorized_bridge_in, equal_slice_bits(ctx_bridger, sender_address));

        int orderId = in_msg_body~load_uint(64);
        cell body = in_msg_body~load_ref();

        send_raw_message(body, 0);

        emit_log_simple(LOG_BRIDGE_IN, begin_cell().store_uint(orderId, 64).end_cell(), 0);

        return ();
    }

    if (op == op::admin::update_address) {
        throw_unless(error::unauthorized_update_address, equal_slice_bits(ctx_owner, sender_address));
        slice load_withdrawer = in_msg_body~load_msg_addr();
        slice load_bridger = in_msg_body~load_msg_addr();
        slice load_bridge_token_address = in_msg_body~load_msg_addr();

        ctx_withdrawer = load_withdrawer;
        ctx_bridger = load_bridger;
        ctx_bridge_token_address = load_bridge_token_address;

        save_data();

        return();
    }

    if (op == op::admin::update_owner) {
        throw_unless(error::unauthorized_update_address, equal_slice_bits(ctx_owner, sender_address));
        slice load_owner = in_msg_body~load_msg_addr();

        ctx_owner = load_owner;

        save_data();

        return();
    }

    throw(0xffff); ;; if the message contains an op that is not known to this contract, we throw
}

;; get methods are a means to conveniently read contract data using, for example, HTTP APIs
;; they are marked with method_id
;; note that unlike in many other smart contract VMs, get methods cannot be called by other contracts

int get_counter() method_id {
    load_data();
    return ctx_counter;
}

int get_id() method_id {
    load_data();
    return ctx_id;
}

slice get_bridge_token_address() method_id {
    load_data();
    return ctx_bridge_token_address;
}

slice get_withdrawer() method_id {
    load_data();
    return ctx_withdrawer;
}

slice get_owner() method_id {
    load_data();
    return ctx_owner;
}

slice get_bridger() method_id {
    load_data();
    return ctx_bridger;
}

